{"version":3,"file":"index-CVqA30YG.js","sources":["../../lib/src/views.ts","../../core/src/notes.ts","../../lib/src/db.ts","../../core/src/parser.ts","../../core/src/codegen.ts","../../lib/src/runtime.ts","../../app/src/main.ts","../../app/src/entry.ts"],"sourcesContent":["// page view\n\ntype MouseEventType = \"click\"| \"mousemove\" | \"mouseup\" | \"mousedown\" | \"drag\" | \"wheel\"\ntype KeyboardEventType = \"keydown\" | \"keyup\"\ntype DomEventType = MouseEventType | KeyboardEventType;\n\nconst mouseEvents : MouseEventType[] = [\"click\", \"mousemove\", \"mouseup\", \"mousedown\", \"drag\", \"wheel\"];\nconst keyboardEvents : KeyboardEventType[] = [\"keydown\", \"keyup\"];\nconst svgNamespace = \"http://www.w3.org/2000/svg\";\nconst svgTags = new Set([\"svg\", \"path\", \"g\", \"line\", \"polyline\", \"polygon\", \"circle\", \"ellipse\", \"rect\", \"text\"]);\nconst allowedAttributeNames = new Set([\"viewBox\",\"width\",\"height\",\"xmlns\",\"d\",\"fill\",\"stroke\",\"stroke-width\",\"stroke-linecap\",\"stroke-linejoin\",\"stroke-dasharray\",\"stroke-dashoffset\",\"x\",\"y\",\"x1\",\"y1\",\"x2\",\"y2\",\"cx\",\"cy\",\"r\",\"rx\",\"ry\",\"points\",\"transform\",\"opacity\",\"font-size\",\"font-family\",\"font-weight\",\"text-anchor\",\"dominant-baseline\",\"dx\",\"dy\"]);\n\n\ntype MouseEvent = {\n  type: MouseEventType\n  target: VDom\n  clientX?: number\n  clientY?: number\n  deltaY?: number\n  currentTarget?: Element\n  preventDefault?: () => void\n};\n\ntype KeyboardEvent = {\n  type: KeyboardEventType\n  key: string,\n  metaKey: boolean,\n  shiftKey: boolean,\n  target: VDom,\n}\n\nexport type DomEvent = MouseEvent | KeyboardEvent\n\n\ntype Listener = (e: DomEvent) => void\n\nexport type UPPER = {\n  add: (parent: VDom, ...el: VDom[])=> void,\n  del: (el: VDom) => void,\n  update: (el: VDom) => void,\n}\n\nexport type VDom = {\n  tag: string\n  textContent: string\n  id: string\n  style: Record<string, string>\n  attrs: Record<string, string>\n  children: VDom[]\n  onEvent?: Listener\n  value? : string\n}\n\ntype DomUpdate = { op: \"DEL\", el: VDom } | { op: \"ADD\", parent: VDom, el: VDom[]} | { op: \"UPDATE\", el: VDom }\n\n\nlet doms = new WeakMap<Element, VDom>();\nlet elements = new WeakMap<VDom, Element>();\n\n\n\nexport const renderDom = (mker: (ufn: UPPER) => VDom): HTMLElement => {\n\n  const render = (dom:VDom) : Element=>{\n    const el = svgTags.has(dom.tag)\n      ? document.createElementNS(svgNamespace, dom.tag)\n      : document.createElement(dom.tag)\n    el.textContent = dom.textContent\n    if ((el instanceof HTMLInputElement || el instanceof HTMLTextAreaElement) && dom.value) el.value = dom.value\n    elements.set(dom, el)\n    doms.set(el, dom)\n    el.append(...dom.children.map(c=>render(c)))\n    Object.entries(dom.attrs).forEach(([k, v]) => {\n      if (allowedAttributeNames.has(k)) el.setAttribute(k, v)\n    })\n    Object.entries(dom.style).forEach(st=>el.style.setProperty(...st))\n    mouseEvents.forEach((type) => el.addEventListener(type, (e) => {\n      const me = e as globalThis.MouseEvent\n      if (dom.onEvent!= undefined) dom.onEvent!({\n        type,\n        target: doms.get(e.target as HTMLElement)!,\n        clientX: me.clientX,\n        clientY: me.clientY,\n        deltaY: type === \"wheel\" ? (me as globalThis.WheelEvent).deltaY : undefined,\n        currentTarget: el,\n        preventDefault: () => e.preventDefault(),\n      })\n    }));\n    keyboardEvents.forEach((type) => el.addEventListener(type, (e) =>{\n      let {key, metaKey, shiftKey} = e as globalThis.KeyboardEvent;\n      if ([\"INPUT\" , \"TEXTAREA\"].includes((e.target as HTMLElement).tagName)) dom.value = (e.target as HTMLInputElement).value\n      if (dom.onEvent!=undefined) dom.onEvent({ type, key, metaKey, shiftKey, target: doms.get(e.target as HTMLElement)!})\n    }))\n    return el\n\n  }\n  return render(mker({\n    add: (parent: VDom, ...el: VDom[]) => {\n      elements.get(parent)?.append(...el.map(e=>render(e)))\n    },\n    del: (el: VDom) => {\n      doms.delete(elements.get(el)!)\n      elements.get(el)?.remove()\n      elements.delete(el)\n    },\n    update: (el: VDom) => {\n      let oldel = elements.get(el)!\n      oldel.replaceWith(render(el))\n      doms.delete(oldel)\n    }\n  })) as HTMLElement\n}\n\n\n\n\ntype KeyListener = (e:KeyboardEvent) => void\ntype MouseListener = (e:MouseEvent) => void\ntype Subscriber = {\n  \"onkeyup\"? : KeyListener\n  \"onkeydown\"? : KeyListener\n  \"onmouseup\"? : MouseListener\n  \"onmousedown\"? : MouseListener\n  \"onclick\"? :MouseListener\n  \"onwheel\"? : MouseListener\n};\n\ntype Content = string | VDom | Content[] | {id: string} | {style: Record<string, string>} | Subscriber | {value: string} | {attrs: Record<string, string>}\n\n\nconst mkDom = (tag: string) => (...content:Content[]) =>{\n\n  let listeners = new Map<KeyboardEventType | MouseEventType, Listener>();\n  let dm : VDom = {tag: tag, style: {}, attrs: {}, textContent: \"\", id: \"\", children: [], onEvent: e=> {\n    let fn = listeners.get(e.type);\n    if (fn) return fn(e)\n    }\n  };\n  let addcontent = (c: Content) => {\n    if (c instanceof Array) c.forEach(addcontent);\n    else if (typeof c == \"string\") dm.textContent = c;\n    else if (c instanceof Object) {\n      if (\"tag\" in c) return dm.children.push(c as VDom)\n      if (\"id\" in c) dm.id = c.id as string;\n      if (\"value\" in c) dm.value = c.value;\n      if (\"attrs\" in c) Object.entries(c.attrs).forEach(([k, v]) => dm.attrs[k] = v)\n      if (\"style\" in c) Object.entries(c.style).forEach(s=> dm.style[s[0].replace(/([A-Z])/g, '-$1')] = s[1])\n      Object.entries(c).forEach(([k,v])=>{\n\n        if (k.startsWith(\"on\")) listeners.set(k.slice(2) as KeyboardEventType, v as Listener)\n      })\n    }\n  }\n\n  addcontent(content)\n\n  return dm\n}\n\nlet div= mkDom(\"div\")\nlet svg = mkDom(\"svg\")\nlet path = mkDom(\"path\")\nlet text = mkDom(\"text\")\n\n\n\n\nconst popup = (...cs:VDom[])=>{\n\n  const dialogfield = div(\n    {\n      style: {\n        background: \"var(--background-color)\",\n        color: \"var(--color)\",\n        padding: \"1em\",\n        paddingBottom: \"2em\",\n        borderRadius: \"1em\",\n        zIndex: \"2000\",\n        overflowY: \"scroll\",\n      }\n    },\n    ...cs)\n\n  const popupbackground = div(\n    {style:{\n      position: \"fixed\",\n      top: \"0\",\n      left: \"0\",\n      width: \"100%\",\n      height: \"100%\",\n      background: \"rgba(166, 166, 166, 0.5)\",\n      display: \"flex\",\n      justifyContent: \"center\",\n      alignItems: \"center\",\n      zIndex: \"2000\",\n    }},\n    dialogfield\n  )\n\n  return popupbackground\n\n}\n\n\nexport const HTML = {\n  div,\n  span: mkDom(\"span\"),\n  p: mkDom(\"p\"),\n  h1: mkDom(\"h1\"),\n  h2: mkDom(\"h2\"),\n  h3: mkDom(\"h3\"),\n  h4: mkDom(\"h4\"),\n  h5: mkDom(\"h5\"),\n  h6: mkDom(\"h6\"),\n  a: mkDom(\"a\"),\n  button: mkDom(\"button\"),\n  input: mkDom(\"input\"),\n  textarea: mkDom(\"textarea\"),\n  pre: mkDom(\"pre\"),\n  svgPath: (pathData: string | string[], options: {\n    viewBox?: string,\n    width?: string,\n    height?: string,\n    fill?: string,\n    stroke?: string,\n    strokeWidth?: string\n  } = {}, ...children: VDom[]) => {\n    const paths = pathData instanceof Array ? pathData : [pathData]\n    const { viewBox = \"0 0 24 24\", width = \"1em\", height = \"1em\", fill = \"currentColor\", stroke, strokeWidth } = options\n    const pathAttrs: Record<string, string> = { fill }\n    if (stroke) pathAttrs.stroke = stroke\n    if (strokeWidth) pathAttrs[\"stroke-width\"] = strokeWidth\n    return svg(\n      { attrs: { viewBox, width, height, xmlns: svgNamespace } },\n      ...paths.map(d => path({ attrs: { ...pathAttrs, d } })),\n      ...children\n    )\n  },\n  svgText: (\n    content: string,\n    options: {\n      x?: string,\n      y?: string,\n      fill?: string,\n      background?: string,\n      fontSize?: string,\n      fontFamily?: string,\n      fontWeight?: string,\n      textAnchor?: string,\n      dominantBaseline?: string,\n      dx?: string,\n      dy?: string\n    } = {}\n  ) => {\n    const attrs: Record<string, string> = {}\n    if (options.x) attrs.x = options.x\n    if (options.y) attrs.y = options.y\n    if (options.fill) attrs.fill = options.fill\n    if (options.background) attrs.background = options.background\n    if (options.fontSize) attrs[\"font-size\"] = options.fontSize\n    if (options.fontFamily) attrs[\"font-family\"] = options.fontFamily\n    if (options.fontWeight) attrs[\"font-weight\"] = options.fontWeight\n    if (options.textAnchor) attrs[\"text-anchor\"] = options.textAnchor\n    if (options.dominantBaseline) attrs[\"dominant-baseline\"] = options.dominantBaseline\n    if (options.dx) attrs.dx = options.dx\n    if (options.dy) attrs.dy = options.dy\n    return text({ attrs }, content)\n  },\n  popup\n}\n","export type Ref = `#${string}`;\n\nconst FNV_OFFSET_1 = 0xcbf29ce484222325n;\nconst FNV_OFFSET_2 = 0x84222325cbf29ce4n;\nconst FNV_PRIME = 0x100000001b3n;\nconst MASK_64 = (1n << 64n) - 1n;\n\nconst hash64 = (value: string, offset: bigint): bigint => {\n  let hash = offset;\n  for (let i = 0; i < value.length; i += 1) {\n    hash ^= BigInt(value.charCodeAt(i));\n    hash = (hash * FNV_PRIME) & MASK_64;\n  }\n  return hash;\n};\n\nconst toHex64 = (value: bigint) => value.toString(16).padStart(16, \"0\");\n\nexport const hash128 = (...data: any): Ref => {\n  const input = JSON.stringify(data);\n  const high = hash64(input, FNV_OFFSET_1);\n  const low = hash64(input, FNV_OFFSET_2);\n  return `#${toHex64(high)}${toHex64(low)}` as Ref;\n};\n\nexport type Jsonable =\n  | string\n  | number\n  | boolean\n  | null\n  | Jsonable[]\n  | { [key: string]: Jsonable };\n\n\nexport type Note = { hash: Ref; data: Jsonable };\n\nexport const tojson = (x: Jsonable) => JSON.stringify(x, null, 2);\nexport const fromjson = (x: string): Jsonable => JSON.parse(x);\n\nexport const isRef = (value: unknown): value is Ref =>\n  typeof value === \"string\" && /^#([a-f0-9]{32})$/i.test(value);\n\nexport const hashData = (value: Jsonable): Ref => {\n  if (isRef(value)) return value;\n  if ([\"string\", \"number\", \"boolean\"].includes(typeof value) || value === null) {\n    return hash128(tojson(value));\n  }\n  if (Array.isArray(value)) return hash128(\"arr\", value.map(hashData));\n  if (typeof value === \"object\"){\n    const entries = Object.entries(value)\n      .sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0))\n      .map(([k, v]) => [k, hashData(v)] as const);\n    return hash128(tojson(Object.fromEntries(entries)));\n  }\n  throw new Error(`unsupported type for hashing: ${typeof value}`);\n};\n","import { fromjson, hashData, isRef, tojson, type Jsonable, type Ref } from \"@hashnotes/core/notes\";\n\nexport type ServerName = \"local\" | \"maincloud\";\ntype CacheOptions = { skipCache?: boolean };\nconst DB_NAME = \"hashnotes\";\n\nlet SERVER: ServerName = localStorage.getItem(\"db_preset\") == \"local\" ? \"local\" : \"maincloud\";\n\nconst baseUrl = (): string => ({\n  local: \"http://localhost:3000\",\n  maincloud: \"https://maincloud.spacetimedb.com\",\n})[SERVER]\n\nconst accessToken = async (): Promise<string | null> => {\n  let tokenkey = () => `access_token:${SERVER}`;\n  let tkey = tokenkey();\n  let token = localStorage.getItem(tkey)\n  if (!token){\n    token = await fetch(`${baseUrl()}/v1/identity`, { method: \"POST\", headers: { \"Content-Type\": \"application/json\" } })\n    .then(r=>r.json()).then(j=>j.token || null)\n    if (tkey != tokenkey()) return accessToken();\n    if (token) localStorage.setItem(tkey, token)\n  }\n  return token\n};\n\nexport const setServer = (value: ServerName) => {\n  localStorage.setItem(\"db_preset\", value);\n  SERVER = value;\n  console.log(\"connect to\", SERVER)\n};\n\nexport let getServer = () => SERVER;\nconsole.log(\"connect to\", SERVER)\n\nconst call = async (name: string, payload: unknown): Promise<string> => {\n  const res = await fetch(`${baseUrl()}/v1/database/${DB_NAME}/call/${name}`, {\n    method: \"POST\",\n    headers: {\"Content-Type\": \"application/json\", Authorization: await accessToken().then(t=>t?`Bearer ${t}`:'')},\n    body: JSON.stringify(payload),\n  });\n  const text = await res.text();\n  if (!res.ok) throw new Error(text);\n  return text;\n};\n\n// Section: in-memory note cache\nconst noteCache = new Map<Ref, Jsonable>();\nconst addInFlight = new Map<Ref, Promise<Ref>>();\nconst getInFlight = new Map<Ref, Promise<Jsonable>>();\n\nexport const clearNoteCache = () => {\n  noteCache.clear();\n  addInFlight.clear();\n  getInFlight.clear();\n};\n\n// Section: note API\nexport const addNote = async (data: Jsonable, options: CacheOptions = {}): Promise<Ref> => {\n  const { skipCache = false } = options;\n  const hash = hashData(data);\n\n  if (!skipCache) {\n    const cached = noteCache.get(hash);\n    if (cached !== undefined) return hash;\n    const pending = addInFlight.get(hash);\n    if (pending) return pending;\n  }\n\n  const p = (async () => {\n    await call(\"add_note\", { data: tojson(data) });\n    if (!skipCache) noteCache.set(hash, data);\n    return hash;\n  })();\n\n  if (!skipCache) addInFlight.set(hash, p);\n  try {\n    return await p;\n  } finally {\n    if (!skipCache) addInFlight.delete(hash);\n  }\n};\n\nexport const getNote = async (hash: Ref, options: CacheOptions = {}): Promise<Jsonable> => {\n  const { skipCache = false } = options;\n\n  if (!skipCache) {\n    const cached = noteCache.get(hash);\n    if (cached !== undefined) return cached;\n\n    const addPending = addInFlight.get(hash);\n    if (addPending) {\n      try {\n        await addPending;\n        const afterAdd = noteCache.get(hash);\n        if (afterAdd !== undefined) return afterAdd;\n      } catch {\n        // fall through\n      }\n    }\n\n    const pending = getInFlight.get(hash);\n    if (pending) return pending;\n  }\n\n  const p = (async () => {\n    const wireValue = await call(\"get_note\", { hash });\n    const data = fromjson(fromjson(wireValue) as string);\n    if (!skipCache) noteCache.set(hash, data);\n    return data;\n  })();\n\n  if (!skipCache) getInFlight.set(hash, p);\n  try {\n    return await p;\n  } finally {\n    if (!skipCache) getInFlight.delete(hash);\n  }\n};\n\n\nexport const deRef = async (value: Jsonable): Promise<Jsonable> =>  isRef(value) ? getNote(value).then(deRef) : value;\nexport const asRef = async (value: Ref | Jsonable): Promise<Ref> => isRef(value) ? value : addNote(value);\n\nexport const callNote = async (fn: Ref | Jsonable, arg?: Ref | Jsonable): Promise<Jsonable> => {\n  const fnRef = await asRef(fn);\n  const argRef = await asRef(arg === undefined ? null : arg);\n  return await call(\"call_note\", { fn: fnRef, arg: argRef }).then(fromjson).then(deRef)\n};\n","type TokenType =\n  | \"number\"\n  | \"string\"\n  | \"identifier\"\n  | \"keyword\"\n  | \"operator\"\n  | \"punct\"\n  | \"eof\";\n\ntype Token = { type: TokenType; value: string; pos: number };\n\nconst keywords = new Set([\n  \"if\",\n  \"else\",\n  \"return\",\n  \"await\",\n  \"typeof\",\n  \"let\",\n  \"const\",\n  \"for\",\n  \"while\",\n  \"in\",\n  \"of\",\n  \"break\",\n  \"continue\",\n  \"true\",\n  \"false\",\n  \"null\",\n]);\n\nconst isIdentStart = (c: string) => /[A-Za-z_$]/.test(c);\nconst isIdentPart = (c: string) => /[A-Za-z0-9_$]/.test(c);\nconst isDigit = (c: string) => /[0-9]/.test(c);\n\nconst tokenize = (src: string): Token[] => {\n  const tokens: Token[] = [];\n  let i = 0;\n  const push = (type: TokenType, value: string, pos: number) => tokens.push({ type, value, pos });\n  const peek = () => src[i];\n  const next = () => src[i++];\n\n  while (i < src.length) {\n    const c = peek();\n    if (c === \" \" || c === \"\\n\" || c === \"\\r\" || c === \"\\t\") {\n      i++;\n      continue;\n    }\n    if (c === \"/\" && src[i + 1] === \"/\") {\n      i += 2;\n      while (i < src.length && src[i] !== \"\\n\") i++;\n      continue;\n    }\n    if (c === \"/\" && src[i + 1] === \"*\") {\n      i += 2;\n      while (i < src.length && !(src[i] === \"*\" && src[i + 1] === \"/\")) i++;\n      i += 2;\n      continue;\n    }\n    if (c === \"'\" || c === \"\\\"\") {\n      const quote = next();\n      let out = \"\";\n      const start = i - 1;\n      while (i < src.length) {\n        const ch = next();\n        if (ch === \"\\\\\") {\n          const esc = next();\n          out += esc;\n        } else if (ch === quote) {\n          break;\n        } else {\n          out += ch;\n        }\n      }\n      push(\"string\", out, start);\n      continue;\n    }\n    if (isDigit(c)) {\n      const start = i;\n      let num = \"\";\n      while (i < src.length && isDigit(peek())) num += next();\n      if (peek() === \".\") {\n        num += next();\n        while (i < src.length && isDigit(peek())) num += next();\n      }\n      push(\"number\", num, start);\n      continue;\n    }\n    if (isIdentStart(c)) {\n      const start = i;\n      let id = \"\";\n      while (i < src.length && isIdentPart(peek())) id += next();\n      if (keywords.has(id)) push(\"keyword\", id, start);\n      else push(\"identifier\", id, start);\n      continue;\n    }\n    const start = i;\n    const two = src.slice(i, i + 2);\n    const three = src.slice(i, i + 3);\n    if (three === \"===\" || three === \"!==\" || three === \"...\") {\n      i += 3;\n      push(\"operator\", three, start);\n      continue;\n    }\n    if (two === \"&&\" || two === \"||\" || two === \"==\" || two === \"!=\" || two === \"<=\" || two === \">=\" || two === \"=>\" || two === \"+=\" || two === \"-=\" || two === \"*=\" || two === \"/=\" || two === \"%=\" || two === \"++\" || two === \"--\") {\n      i += 2;\n      push(\"operator\", two, start);\n      continue;\n    }\n    if (\"+-*/%<>=!.,;:?(){}[]\".includes(c)) {\n      i++;\n      const type = \".;,(){}[]\".includes(c) ? \"punct\" : \"operator\";\n      push(type, c, start);\n      continue;\n    }\n    throw new Error(`Unexpected character '${c}' at ${i}`);\n  }\n  tokens.push({ type: \"eof\", value: \"\", pos: i });\n  return tokens;\n};\n\nexport type Program = { type: \"Program\"; body: Stmt[] };\nexport type BlockStatement = { type: \"BlockStatement\"; body: Stmt[] };\nexport type Stmt =\n  | BlockStatement\n  | { type: \"ExpressionStatement\"; expression: Expr }\n  | { type: \"IfStatement\"; test: Expr; consequent: Stmt; alternate: Stmt | null }\n  | { type: \"ReturnStatement\"; argument: Expr | null }\n  | { type: \"VariableDeclaration\"; kind: \"let\" | \"const\"; declarations: VarDecl[] }\n  | { type: \"BreakStatement\" }\n  | { type: \"ContinueStatement\" }\n  | { type: \"WhileStatement\"; test: Expr; body: Stmt }\n  | {\n      type: \"ForStatement\";\n      init: VarDecl[] | Expr | null;\n      initKind: \"let\" | \"const\" | null;\n      test: Expr | null;\n      update: Expr | null;\n      body: Stmt;\n    }\n  | { type: \"ForInStatement\"; left: VarDecl[] | Expr; leftKind: \"let\" | \"const\" | null; right: Expr; body: Stmt }\n  | { type: \"ForOfStatement\"; left: VarDecl[] | Expr; leftKind: \"let\" | \"const\" | null; right: Expr; body: Stmt };\nexport type Pattern =\n  | Identifier\n  | RestElement\n  | { type: \"ArrayPattern\"; elements: Pattern[] }\n  | { type: \"ObjectPattern\"; properties: (PatternProperty | RestElement)[] };\n\nexport type RestElement = { type: \"RestElement\"; argument: Pattern };\n\nexport type PatternProperty = {\n  type: \"Property\";\n  key: Identifier | Literal;\n  value: Pattern;\n  shorthand: boolean;\n};\n\nexport type VarDecl = { type: \"VariableDeclarator\"; id: Pattern; init: Expr | null };\n\nexport type Expr =\n  | Identifier\n  | SpreadElement\n  | Literal\n  | { type: \"ArrayExpression\"; elements: (Expr | SpreadElement)[] }\n  | { type: \"ObjectExpression\"; properties: (Property | SpreadElement)[] }\n  | { type: \"AwaitExpression\"; argument: Expr }\n  | { type: \"CallExpression\"; callee: Expr; arguments: (Expr | SpreadElement)[] }\n  | { type: \"MemberExpression\"; object: Expr; property: Expr; computed: boolean }\n  | { type: \"AssignmentExpression\"; operator: string; left: Expr; right: Expr }\n  | { type: \"UpdateExpression\"; operator: \"++\" | \"--\"; argument: Expr; prefix: boolean }\n  | { type: \"BinaryExpression\"; operator: string; left: Expr; right: Expr }\n  | { type: \"LogicalExpression\"; operator: string; left: Expr; right: Expr }\n  | { type: \"UnaryExpression\"; operator: string; argument: Expr }\n  | { type: \"ConditionalExpression\"; test: Expr; consequent: Expr; alternate: Expr }\n  | { type: \"ArrowFunctionExpression\"; params: Pattern[]; body: Expr | BlockStatement; async: boolean };\n\nexport type Identifier = { type: \"Identifier\"; name: string };\nexport type SpreadElement = { type: \"SpreadElement\"; argument: Expr };\nexport type Literal = { type: \"Literal\"; value: string | number | boolean | null };\nexport type Property = { type: \"Property\"; key: Identifier | Literal; value: Expr; shorthand: boolean };\n\nexport const validateScopes = (program: Program, allowedGlobals: string[] = []) => {\n  const errors: string[] = [];\n  const globals = new Set(allowedGlobals);\n  const scopes: Array<Set<string>> = [new Set()];\n\n  const declare = (name: string) => scopes[scopes.length - 1].add(name);\n  const isDeclared = (name: string) => scopes.some((s) => s.has(name)) || globals.has(name);\n  const enter = () => scopes.push(new Set());\n  const exit = () => { scopes.pop(); };\n  const checkIdent = (name: string) => {\n    if (!isDeclared(name)) errors.push(`undeclared: ${name}`);\n  };\n\n  const declarePattern = (p: Pattern) => {\n    if (p.type === \"Identifier\") declare(p.name);\n    else if (p.type === \"RestElement\") declarePattern(p.argument);\n    else if (p.type === \"ArrayPattern\") p.elements.forEach(declarePattern);\n    else p.properties.forEach((prop) => {\n      if (prop.type === \"RestElement\") declarePattern(prop.argument);\n      else declarePattern(prop.value);\n    });\n  };\n\n  const visitExpr = (e: Expr): void => {\n    switch (e.type) {\n      case \"Identifier\":\n        checkIdent(e.name);\n        return;\n      case \"Literal\":\n        return;\n      case \"SpreadElement\":\n        visitExpr(e.argument);\n        return;\n      case \"ArrayExpression\":\n        e.elements.forEach((el) => visitExpr(el));\n        return;\n      case \"ObjectExpression\":\n        e.properties.forEach((p) => {\n          if (p.type === \"SpreadElement\") visitExpr(p.argument);\n          else visitExpr(p.value);\n        });\n        return;\n      case \"AwaitExpression\":\n        visitExpr(e.argument);\n        return;\n      case \"CallExpression\":\n        visitExpr(e.callee);\n        e.arguments.forEach((a) => visitExpr(a));\n        return;\n      case \"MemberExpression\":\n        visitExpr(e.object);\n        if (e.computed) visitExpr(e.property);\n        return;\n      case \"AssignmentExpression\":\n        visitExpr(e.left);\n        visitExpr(e.right);\n        return;\n      case \"UpdateExpression\":\n        visitExpr(e.argument);\n        return;\n      case \"BinaryExpression\":\n      case \"LogicalExpression\":\n        visitExpr(e.left);\n        visitExpr(e.right);\n        return;\n      case \"UnaryExpression\":\n        visitExpr(e.argument);\n        return;\n      case \"ConditionalExpression\":\n        visitExpr(e.test);\n        visitExpr(e.consequent);\n        visitExpr(e.alternate);\n        return;\n      case \"ArrowFunctionExpression\":\n        enter();\n        e.params.forEach(declarePattern);\n        if (e.body.type === \"BlockStatement\") visitStmt(e.body);\n        else visitExpr(e.body);\n        exit();\n        return;\n    }\n  };\n\n  const visitVarDecl = (d: VarDecl) => {\n    declarePattern(d.id);\n    if (d.init) visitExpr(d.init);\n  };\n\n  const visitStmt = (s: Stmt): void => {\n    switch (s.type) {\n      case \"BlockStatement\":\n        enter();\n        s.body.forEach(visitStmt);\n        exit();\n        return;\n      case \"ExpressionStatement\":\n        visitExpr(s.expression);\n        return;\n      case \"IfStatement\":\n        visitExpr(s.test);\n        visitStmt(s.consequent);\n        if (s.alternate) visitStmt(s.alternate);\n        return;\n      case \"ReturnStatement\":\n        if (s.argument) visitExpr(s.argument);\n        return;\n      case \"VariableDeclaration\":\n        s.declarations.forEach(visitVarDecl);\n        return;\n      case \"WhileStatement\":\n        visitExpr(s.test);\n        visitStmt(s.body);\n        return;\n      case \"ForStatement\": {\n        enter();\n        if (Array.isArray(s.init)) s.init.forEach(visitVarDecl);\n        else if (s.init) visitExpr(s.init);\n        if (s.test) visitExpr(s.test);\n        if (s.update) visitExpr(s.update);\n        visitStmt(s.body);\n        exit();\n        return;\n      }\n      case \"ForInStatement\":\n      case \"ForOfStatement\": {\n        enter();\n        if (Array.isArray(s.left)) s.left.forEach(visitVarDecl);\n        else visitExpr(s.left);\n        visitExpr(s.right);\n        visitStmt(s.body);\n        exit();\n        return;\n      }\n      case \"BreakStatement\":\n      case \"ContinueStatement\":\n        return;\n    }\n  };\n\n  program.body.forEach(visitStmt);\n  return errors;\n};\n\nexport const validateNoPrototype = (program: Program) => {\n  const errors: string[] = [];\n  const forbiddenMembers = new Set([\"prototype\", \"constructor\", \"__proto__\"]);\n  const visitExpr = (e: Expr): void => {\n    switch (e.type) {\n      case \"MemberExpression\":\n        if (!e.computed && e.property.type === \"Identifier\" && forbiddenMembers.has(e.property.name)) {\n          errors.push(\"prototype access\");\n        }\n        if (e.computed && !(e.property.type === \"Literal\" && typeof e.property.value === \"number\")) {\n          errors.push(\"only numeric literal indexing allowed\");\n        }\n        visitExpr(e.object);\n        if (e.computed) visitExpr(e.property);\n        return;\n      case \"SpreadElement\":\n        visitExpr(e.argument);\n        return;\n      case \"CallExpression\":\n        visitExpr(e.callee);\n        e.arguments.forEach((a) => visitExpr(a));\n        return;\n      case \"AwaitExpression\":\n        visitExpr(e.argument);\n        return;\n      case \"ArrayExpression\":\n        e.elements.forEach((el) => visitExpr(el));\n        return;\n      case \"ObjectExpression\":\n        e.properties.forEach((p) => {\n          if (p.type === \"SpreadElement\") visitExpr(p.argument);\n          else visitExpr(p.value);\n        });\n        return;\n      case \"AssignmentExpression\":\n        visitExpr(e.left);\n        visitExpr(e.right);\n        return;\n      case \"UpdateExpression\":\n        visitExpr(e.argument);\n        return;\n      case \"BinaryExpression\":\n      case \"LogicalExpression\":\n        visitExpr(e.left);\n        visitExpr(e.right);\n        return;\n      case \"UnaryExpression\":\n        visitExpr(e.argument);\n        return;\n      case \"ConditionalExpression\":\n        visitExpr(e.test);\n        visitExpr(e.consequent);\n        visitExpr(e.alternate);\n        return;\n      case \"ArrowFunctionExpression\":\n        if (e.body.type === \"BlockStatement\") visitStmt(e.body);\n        else visitExpr(e.body);\n        return;\n      case \"Identifier\":\n      case \"Literal\":\n        return;\n    }\n  };\n  const visitStmt = (s: Stmt): void => {\n    switch (s.type) {\n      case \"BlockStatement\":\n        s.body.forEach(visitStmt);\n        return;\n      case \"ExpressionStatement\":\n        visitExpr(s.expression);\n        return;\n      case \"IfStatement\":\n        visitExpr(s.test);\n        visitStmt(s.consequent);\n        if (s.alternate) visitStmt(s.alternate);\n        return;\n      case \"ReturnStatement\":\n        if (s.argument) visitExpr(s.argument);\n        return;\n      case \"VariableDeclaration\":\n        s.declarations.forEach((d) => d.init && visitExpr(d.init));\n        return;\n      case \"WhileStatement\":\n        visitExpr(s.test);\n        visitStmt(s.body);\n        return;\n      case \"ForStatement\":\n        if (Array.isArray(s.init)) s.init.forEach((d) => d.init && visitExpr(d.init));\n        else if (s.init) visitExpr(s.init);\n        if (s.test) visitExpr(s.test);\n        if (s.update) visitExpr(s.update);\n        visitStmt(s.body);\n        return;\n      case \"ForInStatement\":\n      case \"ForOfStatement\":\n        if (Array.isArray(s.left)) s.left.forEach((d) => d.init && visitExpr(d.init));\n        else visitExpr(s.left);\n        visitExpr(s.right);\n        visitStmt(s.body);\n        return;\n      case \"BreakStatement\":\n      case \"ContinueStatement\":\n        return;\n    }\n  };\n  program.body.forEach(visitStmt);\n  return errors;\n};\n\nexport const parse = (src: string): Program => {\n  const tokens = tokenize(src);\n  let i = 0;\n  const peek = () => tokens[i];\n  const next = () => tokens[i++];\n  const eat = (type: TokenType, value?: string) => {\n    const t = peek();\n    if (t.type !== type || (value !== undefined && t.value !== value)) {\n      throw new Error(`Expected ${value ?? type} at ${t.pos}`);\n    }\n    return next();\n  };\n  const match = (type: TokenType, value?: string) => {\n    const t = peek();\n    return t.type === type && (value === undefined || t.value === value);\n  };\n\n  const parseProgram = (): Program => {\n    const body: Stmt[] = [];\n    while (!match(\"eof\")) body.push(parseStatement());\n    return { type: \"Program\", body };\n  };\n\n  const parseStatement = (): Stmt => {\n    if (match(\"punct\", \"{\")) return parseBlock();\n    if (match(\"keyword\", \"if\")) return parseIf();\n    if (match(\"keyword\", \"while\")) return parseWhile();\n    if (match(\"keyword\", \"for\")) return parseFor();\n    if (match(\"keyword\", \"break\")) { next(); if (match(\"punct\", \";\")) next(); return { type: \"BreakStatement\" }; }\n    if (match(\"keyword\", \"continue\")) { next(); if (match(\"punct\", \";\")) next(); return { type: \"ContinueStatement\" }; }\n    if (match(\"keyword\", \"return\")) return parseReturn();\n    if (match(\"keyword\", \"let\") || match(\"keyword\", \"const\")) return parseVarDecl();\n    const expr = parseExpression();\n    if (match(\"punct\", \";\")) next();\n    return { type: \"ExpressionStatement\", expression: expr };\n  };\n\n  const parseBlock = (): BlockStatement => {\n    eat(\"punct\", \"{\");\n    const body: Stmt[] = [];\n    while (!match(\"punct\", \"}\")) body.push(parseStatement());\n    eat(\"punct\", \"}\");\n    return { type: \"BlockStatement\", body };\n  };\n\n  const parseIf = (): Stmt => {\n    eat(\"keyword\", \"if\");\n    eat(\"punct\", \"(\");\n    const test = parseExpression();\n    eat(\"punct\", \")\");\n    const consequent = parseStatement();\n    const alternate = match(\"keyword\", \"else\") ? (next(), parseStatement()) : null;\n    return { type: \"IfStatement\", test, consequent, alternate };\n  };\n\n  const parseReturn = (): Stmt => {\n    eat(\"keyword\", \"return\");\n    if (match(\"punct\", \";\")) {\n      next();\n      return { type: \"ReturnStatement\", argument: null };\n    }\n    const argument = match(\"punct\", \"}\") ? null : parseExpression();\n    if (match(\"punct\", \";\")) next();\n    return { type: \"ReturnStatement\", argument };\n  };\n\n  const parseVarDeclCore = (consumeSemi: boolean) => {\n    const kind = next().value as \"let\" | \"const\";\n    const declarations: VarDecl[] = [];\n    do {\n      const id = parsePattern();\n      const init = match(\"operator\", \"=\") ? (next(), parseExpression()) : null;\n      declarations.push({ type: \"VariableDeclarator\", id, init });\n      if (!match(\"punct\", \",\")) break;\n      next();\n    } while (true);\n    if (consumeSemi && match(\"punct\", \";\")) next();\n    return { kind, declarations };\n  };\n\n  const parseVarDecl = (): Stmt => {\n    const { kind, declarations } = parseVarDeclCore(true);\n    return { type: \"VariableDeclaration\", kind, declarations };\n  };\n\n  const parseWhile = (): Stmt => {\n    eat(\"keyword\", \"while\");\n    eat(\"punct\", \"(\");\n    const test = parseExpression();\n    eat(\"punct\", \")\");\n    const body = parseStatement();\n    return { type: \"WhileStatement\", test, body };\n  };\n\n  const parseFor = (): Stmt => {\n    eat(\"keyword\", \"for\");\n    eat(\"punct\", \"(\");\n    let init: VarDecl[] | Expr | null = null;\n    let initKind: \"let\" | \"const\" | null = null;\n    if (!match(\"punct\", \";\")) {\n      if (match(\"keyword\", \"let\") || match(\"keyword\", \"const\")) {\n        const parsed = parseVarDeclCore(false);\n        init = parsed.declarations;\n        initKind = parsed.kind;\n      } else {\n        init = parseExpression();\n      }\n    }\n    if (match(\"keyword\", \"in\") || match(\"keyword\", \"of\")) {\n      const kind = next().value;\n      const right = parseExpression();\n      eat(\"punct\", \")\");\n      const body = parseStatement();\n      if (!init) throw new Error(`Expected initializer before ${kind} at ${peek().pos}`);\n      return kind === \"in\"\n        ? { type: \"ForInStatement\", left: init, leftKind: initKind, right, body }\n        : { type: \"ForOfStatement\", left: init, leftKind: initKind, right, body };\n    }\n    eat(\"punct\", \";\");\n    const test = match(\"punct\", \";\") ? null : parseExpression();\n    eat(\"punct\", \";\");\n    const update = match(\"punct\", \")\") ? null : parseExpression();\n    eat(\"punct\", \")\");\n    const body = parseStatement();\n    return { type: \"ForStatement\", init, initKind, test, update, body };\n  };\n\n  const parseExpression = (): Expr => parseAssignment();\n\n  const parseAssignment = (): Expr => {\n    const left = parseConditional();\n    if (match(\"operator\", \"=\") || match(\"operator\", \"+=\") || match(\"operator\", \"-=\") || match(\"operator\", \"*=\") || match(\"operator\", \"/=\") || match(\"operator\", \"%=\")) {\n      const op = next().value;\n      const right = parseAssignment();\n      return { type: \"AssignmentExpression\", operator: op, left, right };\n    }\n    return left;\n  };\n\n  const parseConditional = (): Expr => {\n    let test = parseLogicalOr();\n    if (match(\"operator\", \"?\")) {\n      next();\n      const consequent = parseExpression();\n      eat(\"operator\", \":\");\n      const alternate = parseExpression();\n      return { type: \"ConditionalExpression\", test, consequent, alternate };\n    }\n    return test;\n  };\n\n  const parseLogicalOr = (): Expr => {\n    let left = parseLogicalAnd();\n    while (match(\"operator\", \"||\")) {\n      const op = next().value;\n      const right = parseLogicalAnd();\n      left = { type: \"LogicalExpression\", operator: op, left, right };\n    }\n    return left;\n  };\n\n  const parseLogicalAnd = (): Expr => {\n    let left = parseEquality();\n    while (match(\"operator\", \"&&\")) {\n      const op = next().value;\n      const right = parseEquality();\n      left = { type: \"LogicalExpression\", operator: op, left, right };\n    }\n    return left;\n  };\n\n  const parseEquality = (): Expr => {\n    let left = parseRelational();\n    while (match(\"operator\", \"==\") || match(\"operator\", \"!=\") || match(\"operator\", \"===\") || match(\"operator\", \"!==\")) {\n      const op = next().value;\n      const right = parseRelational();\n      left = { type: \"BinaryExpression\", operator: op, left, right };\n    }\n    return left;\n  };\n\n  const parseRelational = (): Expr => {\n    let left = parseAdditive();\n    while (match(\"operator\", \"<\") || match(\"operator\", \"<=\") || match(\"operator\", \">\") || match(\"operator\", \">=\")) {\n      const op = next().value;\n      const right = parseAdditive();\n      left = { type: \"BinaryExpression\", operator: op, left, right };\n    }\n    return left;\n  };\n\n  const parseAdditive = (): Expr => {\n    let left = parseMultiplicative();\n    while (match(\"operator\", \"+\") || match(\"operator\", \"-\")) {\n      const op = next().value;\n      const right = parseMultiplicative();\n      left = { type: \"BinaryExpression\", operator: op, left, right };\n    }\n    return left;\n  };\n\n  const parseMultiplicative = (): Expr => {\n    let left = parseUnary();\n    while (match(\"operator\", \"*\") || match(\"operator\", \"/\") || match(\"operator\", \"%\")) {\n      const op = next().value;\n      const right = parseUnary();\n      left = { type: \"BinaryExpression\", operator: op, left, right };\n    }\n    return left;\n  };\n\n  const parseUnary = (): Expr => {\n    if (match(\"keyword\", \"await\")) {\n      next();\n      return { type: \"AwaitExpression\", argument: parseUnary() };\n    }\n    if (match(\"operator\", \"++\") || match(\"operator\", \"--\")) {\n      const op = next().value as \"++\" | \"--\";\n      return { type: \"UpdateExpression\", operator: op, argument: parseUnary(), prefix: true };\n    }\n    if (match(\"keyword\", \"typeof\")) {\n      next();\n      return { type: \"UnaryExpression\", operator: \"typeof\", argument: parseUnary() };\n    }\n    if (match(\"operator\", \"!\") || match(\"operator\", \"-\") || match(\"operator\", \"+\")) {\n      const op = next().value;\n      return { type: \"UnaryExpression\", operator: op, argument: parseUnary() };\n    }\n    return parsePostfix();\n  };\n\n  const parsePostfix = (): Expr => {\n    let expr = parseArrowOrPrimary();\n    while (true) {\n      if (match(\"operator\", \"++\") || match(\"operator\", \"--\")) {\n        const op = next().value as \"++\" | \"--\";\n        expr = { type: \"UpdateExpression\", operator: op, argument: expr, prefix: false };\n        continue;\n      }\n      if (match(\"punct\", \"(\")) {\n        const args = parseArguments();\n        expr = { type: \"CallExpression\", callee: expr, arguments: args };\n        continue;\n      }\n      if (match(\"punct\", \".\")) {\n        next();\n        const prop = parseIdentifier();\n        expr = { type: \"MemberExpression\", object: expr, property: prop, computed: false };\n        continue;\n      }\n      if (match(\"punct\", \"[\")) {\n        next();\n        const prop = parseExpression();\n        eat(\"punct\", \"]\");\n        expr = { type: \"MemberExpression\", object: expr, property: prop, computed: true };\n        continue;\n      }\n      break;\n    }\n    return expr;\n  };\n\n  const parseArrowOrPrimary = (): Expr => {\n    if (match(\"identifier\", \"async\")) {\n      const start = i;\n      next();\n      if (match(\"identifier\")) {\n        const id = parseIdentifier();\n        if (match(\"operator\", \"=>\")) {\n          next();\n          const body = match(\"punct\", \"{\") ? parseBlock() : parseExpression();\n          return { type: \"ArrowFunctionExpression\", params: [id], body, async: true };\n        }\n      } else if (match(\"punct\", \"(\")) {\n        next();\n        const params: Pattern[] = [];\n        let isParams = true;\n        try {\n          if (!match(\"punct\", \")\")) {\n            do {\n              params.push(parsePattern());\n              if (!match(\"punct\", \",\")) break;\n              next();\n            } while (true);\n          }\n        } catch {\n          isParams = false;\n        }\n        if (isParams && match(\"punct\", \")\")) {\n          next();\n          if (match(\"operator\", \"=>\")) {\n            next();\n            const body = match(\"punct\", \"{\") ? parseBlock() : parseExpression();\n            return { type: \"ArrowFunctionExpression\", params, body, async: true };\n          }\n        }\n      }\n      i = start;\n    }\n\n    if (match(\"identifier\")) {\n      const id = parseIdentifier();\n      if (match(\"operator\", \"=>\")) {\n        next();\n        const body = match(\"punct\", \"{\") ? parseBlock() : parseExpression();\n        return { type: \"ArrowFunctionExpression\", params: [id], body, async: false };\n      }\n      return id;\n    }\n    if (match(\"punct\", \"(\")) {\n      const start = i;\n      next();\n      const params: Pattern[] = [];\n      let isParams = true;\n      try {\n        if (!match(\"punct\", \")\")) {\n          do {\n            params.push(parsePattern());\n            if (!match(\"punct\", \",\")) break;\n            next();\n          } while (true);\n        }\n      } catch {\n        isParams = false;\n      }\n      if (isParams && match(\"punct\", \")\")) {\n        next();\n        if (match(\"operator\", \"=>\")) {\n          next();\n          const body = match(\"punct\", \"{\") ? parseBlock() : parseExpression();\n          return { type: \"ArrowFunctionExpression\", params, body, async: false };\n        }\n      }\n      i = start;\n      eat(\"punct\", \"(\");\n      const expr = parseExpression();\n      eat(\"punct\", \")\");\n      return expr;\n    }\n    return parsePrimary();\n  };\n\n  const parsePrimary = (): Expr => {\n    if (match(\"number\")) return { type: \"Literal\", value: Number(next().value) };\n    if (match(\"string\")) return { type: \"Literal\", value: next().value };\n    if (match(\"keyword\", \"true\")) { next(); return { type: \"Literal\", value: true }; }\n    if (match(\"keyword\", \"false\")) { next(); return { type: \"Literal\", value: false }; }\n    if (match(\"keyword\", \"null\")) { next(); return { type: \"Literal\", value: null }; }\n    if (match(\"punct\", \"[\")) return parseArray();\n    if (match(\"punct\", \"{\")) return parseObject();\n    if (match(\"identifier\")) return parseIdentifier();\n    throw new Error(`Unexpected token ${peek().type} ${peek().value} at ${peek().pos}`);\n  };\n\n  const parseArray = (): Expr => {\n    eat(\"punct\", \"[\");\n    const elements: (Expr | SpreadElement)[] = [];\n    if (!match(\"punct\", \"]\")) {\n      do {\n        if (match(\"operator\", \"...\")) {\n          next();\n          elements.push({ type: \"SpreadElement\", argument: parseExpression() });\n        } else {\n          elements.push(parseExpression());\n        }\n        if (!match(\"punct\", \",\")) break;\n        next();\n      } while (true);\n    }\n    eat(\"punct\", \"]\");\n    return { type: \"ArrayExpression\", elements };\n  };\n\n  const parseObject = (): Expr => {\n    eat(\"punct\", \"{\");\n    const properties: (Property | SpreadElement)[] = [];\n    if (!match(\"punct\", \"}\")) {\n      do {\n        if (match(\"operator\", \"...\")) {\n          next();\n          properties.push({ type: \"SpreadElement\", argument: parseExpression() });\n          if (!match(\"punct\", \",\")) break;\n          next();\n          continue;\n        }\n        let key: Identifier | Literal;\n        let shorthand = false;\n        if (match(\"identifier\")) key = parseIdentifier();\n        else if (match(\"string\")) key = { type: \"Literal\", value: next().value };\n        else if (match(\"number\")) key = { type: \"Literal\", value: Number(next().value) };\n        else throw new Error(`Expected object key at ${peek().pos}`);\n        let value: Expr;\n        if (match(\"operator\", \":\")) {\n          next();\n          value = parseExpression();\n        } else {\n          if (key.type !== \"Identifier\") throw new Error(`Expected ':' after key at ${peek().pos}`);\n          value = key;\n          shorthand = true;\n        }\n        properties.push({ type: \"Property\", key, value, shorthand });\n        if (!match(\"punct\", \",\")) break;\n        next();\n      } while (true);\n    }\n    eat(\"punct\", \"}\");\n    return { type: \"ObjectExpression\", properties };\n  };\n\n  const parseArguments = (): (Expr | SpreadElement)[] => {\n    eat(\"punct\", \"(\");\n    const args: (Expr | SpreadElement)[] = [];\n    if (!match(\"punct\", \")\")) {\n      do {\n        if (match(\"operator\", \"...\")) {\n          next();\n          args.push({ type: \"SpreadElement\", argument: parseExpression() });\n        } else {\n          args.push(parseExpression());\n        }\n        if (!match(\"punct\", \",\")) break;\n        next();\n      } while (true);\n    }\n    eat(\"punct\", \")\");\n    return args;\n  };\n\n  const parseIdentifier = (): Identifier => {\n    const t = eat(\"identifier\");\n    return { type: \"Identifier\", name: t.value };\n  };\n\n  const parsePattern = (): Pattern => {\n    if (match(\"operator\", \"...\")) {\n      next();\n      return { type: \"RestElement\", argument: parsePattern() };\n    }\n    if (match(\"punct\", \"[\")) {\n      eat(\"punct\", \"[\");\n      const elements: Pattern[] = [];\n      if (!match(\"punct\", \"]\")) {\n        do {\n          elements.push(parsePattern());\n          if (!match(\"punct\", \",\")) break;\n          next();\n        } while (true);\n      }\n      eat(\"punct\", \"]\");\n      return { type: \"ArrayPattern\", elements };\n    }\n    if (match(\"punct\", \"{\")) {\n      eat(\"punct\", \"{\");\n      const properties: (PatternProperty | RestElement)[] = [];\n      if (!match(\"punct\", \"}\")) {\n        do {\n          if (match(\"operator\", \"...\")) {\n            next();\n            properties.push({ type: \"RestElement\", argument: parsePattern() });\n            if (!match(\"punct\", \",\")) break;\n            next();\n            continue;\n          }\n          let key: Identifier | Literal;\n          let shorthand = false;\n          if (match(\"identifier\")) key = parseIdentifier();\n          else if (match(\"string\")) key = { type: \"Literal\", value: next().value };\n          else if (match(\"number\")) key = { type: \"Literal\", value: Number(next().value) };\n          else throw new Error(`Expected object pattern key at ${peek().pos}`);\n          let value: Pattern;\n          if (match(\"operator\", \":\")) {\n            next();\n            value = parsePattern();\n          } else {\n            if (key.type !== \"Identifier\") throw new Error(`Expected ':' after key at ${peek().pos}`);\n            value = key;\n            shorthand = true;\n          }\n          properties.push({ type: \"Property\", key, value, shorthand });\n          if (!match(\"punct\", \",\")) break;\n          next();\n        } while (true);\n      }\n      eat(\"punct\", \"}\");\n      return { type: \"ObjectPattern\", properties };\n    }\n    return parseIdentifier();\n  };\n\n  return parseProgram();\n};\n","/**\n * codegen.ts — Security-critical code generation and runtime execution.\n *\n * This module takes a validated AST (from parser.ts) and produces JavaScript\n * source strings that are evaluated via `new Function()`. Every identifier\n * emitted into the generated code is validated by `assertSafeIdent` as a\n * defense-in-depth measure (the parser already produces safe names, but the\n * codegen must not trust its input).\n *\n * Audit surface: renderExpr, renderStmt, renderPattern, and the runner\n * functions that interpolate fuel references.\n */\n\nimport type {\n  Program, Stmt, Expr, Literal, Property, Pattern, PatternProperty,\n  Identifier, SpreadElement, BlockStatement, VarDecl,\n} from \"./parser.ts\";\nimport { parse, validateScopes, validateNoPrototype } from \"./parser.ts\";\n\n// ---------------------------------------------------------------------------\n// Defense-in-depth: identifier validation\n// ---------------------------------------------------------------------------\n\nconst SAFE_IDENT_RE = /^[A-Za-z_$][A-Za-z0-9_$]*$/;\n\nconst FORBIDDEN_IDENTS = new Set([\n  \"eval\", \"arguments\", \"this\", \"globalThis\", \"window\", \"document\",\n  \"self\", \"top\", \"parent\", \"frames\",\n  \"process\", \"require\", \"module\", \"exports\", \"__dirname\", \"__filename\",\n  \"importScripts\",\n]);\n\nexport const assertSafeIdent = (name: string): void => {\n  if (!SAFE_IDENT_RE.test(name))\n    throw new Error(`unsafe identifier in codegen: ${JSON.stringify(name)}`);\n  if (FORBIDDEN_IDENTS.has(name))\n    throw new Error(`forbidden identifier in codegen: ${name}`);\n};\n\n// ---------------------------------------------------------------------------\n// Code generation (AST → JS source string)\n// ---------------------------------------------------------------------------\n\nconst renderLiteral = (v: Literal[\"value\"]) => {\n  if (v === null) return \"null\";\n  if (typeof v === \"string\") return JSON.stringify(v);\n  return String(v);\n};\n\nconst renderExpr = (e: Expr): string => {\n  switch (e.type) {\n    case \"Identifier\":\n      assertSafeIdent(e.name);\n      return e.name;\n    case \"SpreadElement\":\n      return `...${renderExpr(e.argument)}`;\n    case \"Literal\":\n      return renderLiteral(e.value);\n    case \"ArrayExpression\":\n      return `[${e.elements.map(renderExpr).join(\", \")}]`;\n    case \"ObjectExpression\":\n      return `{${e.properties.map((p) => p.type === \"SpreadElement\" ? `...${renderExpr(p.argument)}` : renderProp(p)).join(\", \")}}`;\n    case \"AwaitExpression\":\n      return `(await ${renderExpr(e.argument)})`;\n    case \"CallExpression\": {\n      const calleeStr = renderExpr(e.callee);\n      const needsParens = e.callee.type === \"ArrowFunctionExpression\";\n      return `${needsParens ? \"(\" : \"\"}${calleeStr}${needsParens ? \")\" : \"\"}(${e.arguments.map(renderExpr).join(\", \")})`;\n    }\n    case \"MemberExpression\":\n      return e.computed\n        ? `${renderExpr(e.object)}[${renderExpr(e.property)}]`\n        : `${renderExpr(e.object)}.${renderExpr(e.property)}`;\n    case \"AssignmentExpression\":\n      return `${renderExpr(e.left)} ${e.operator} ${renderExpr(e.right)}`;\n    case \"UpdateExpression\":\n      return e.prefix\n        ? `${e.operator}${renderExpr(e.argument)}`\n        : `${renderExpr(e.argument)}${e.operator}`;\n    case \"BinaryExpression\":\n    case \"LogicalExpression\":\n      return `(${renderExpr(e.left)} ${e.operator} ${renderExpr(e.right)})`;\n    case \"UnaryExpression\":\n      return e.operator === \"typeof\"\n        ? `(${e.operator} ${renderExpr(e.argument)})`\n        : `(${e.operator}${renderExpr(e.argument)})`;\n    case \"ConditionalExpression\":\n      return `(${renderExpr(e.test)} ? ${renderExpr(e.consequent)} : ${renderExpr(e.alternate)})`;\n    case \"ArrowFunctionExpression\":\n      return renderArrow(e);\n  }\n};\n\nconst renderProp = (p: Property) => {\n  const key =\n    p.key.type === \"Identifier\" ? p.key.name : renderLiteral(p.key.value);\n  if (p.shorthand && p.value.type === \"Identifier\" && p.value.name === key) {\n    assertSafeIdent(key);\n    return key;\n  }\n  return `${key}: ${renderExpr(p.value)}`;\n};\n\nconst renderArrow = (e: Extract<Expr, { type: \"ArrowFunctionExpression\" }>) => {\n  const params = `(${e.params.map(renderPattern).join(\", \")})`;\n  const prefix = e.async ? \"async \" : \"\";\n  if (e.body.type === \"BlockStatement\") {\n    return `${prefix}${params} => ${renderStmt(e.body, true)}`;\n  }\n  return `${prefix}${params} => { __burn(); return ${renderExpr(e.body)}; }`;\n};\n\nconst renderStmt = (s: Stmt, inFn = false): string => {\n  const burn = inFn ? \"__burn();\" : \"\";\n  const renderLoopBody = (body: Stmt) => {\n    if (body.type === \"BlockStatement\") {\n      const inner = body.body.map((b) => renderStmt(b, inFn)).join(\"\");\n      return `{__burn();${inner}}`;\n    }\n    return `{__burn();${renderStmt(body, inFn)}}`;\n  };\n  switch (s.type) {\n    case \"BlockStatement\":\n      return `{${s.body.map((b) => renderStmt(b, inFn)).join(\"\")}}`;\n    case \"ExpressionStatement\":\n      return `${burn}${renderExpr(s.expression)};`;\n    case \"IfStatement\": {\n      const wrap = (stmt: Stmt) =>\n        stmt.type === \"BlockStatement\" ? renderStmt(stmt, inFn) : `{${renderStmt(stmt, inFn)}}`;\n      return `${burn}if (${renderExpr(s.test)}) ${wrap(s.consequent)}${s.alternate ? ` else ${wrap(s.alternate)}` : \"\"}`;\n    }\n    case \"ReturnStatement\":\n      return `${burn}return${s.argument ? ` ${renderExpr(s.argument)}` : \"\"};`;\n    case \"VariableDeclaration\":\n      return `${burn}${s.kind} ${s.declarations.map(renderDecl).join(\", \")};`;\n    case \"BreakStatement\":\n      return `${burn}break;`;\n    case \"ContinueStatement\":\n      return `${burn}continue;`;\n    case \"WhileStatement\":\n      return `${burn}while (${renderExpr(s.test)}) ${renderLoopBody(s.body)}`;\n    case \"ForStatement\": {\n      const init =\n        s.init == null\n          ? \"\"\n          : Array.isArray(s.init)\n          ? `${s.initKind} ${s.init.map(renderDecl).join(\", \")}`\n          : renderExpr(s.init);\n      const test = s.test ? renderExpr(s.test) : \"\";\n      const update = s.update ? renderExpr(s.update) : \"\";\n      return `${burn}for (${init}; ${test}; ${update}) ${renderLoopBody(s.body)}`;\n    }\n    case \"ForInStatement\": {\n      const left = Array.isArray(s.left)\n        ? `${s.leftKind} ${s.left.map(renderDecl).join(\", \")}`\n        : renderExpr(s.left);\n      return `${burn}for (${left} in ${renderExpr(s.right)}) ${renderLoopBody(s.body)}`;\n    }\n    case \"ForOfStatement\": {\n      const left = Array.isArray(s.left)\n        ? `${s.leftKind} ${s.left.map(renderDecl).join(\", \")}`\n        : renderExpr(s.left);\n      return `${burn}for (${left} of ${renderExpr(s.right)}) ${renderLoopBody(s.body)}`;\n    }\n  }\n};\n\nconst renderDecl = (d: VarDecl) =>\n  `${renderPattern(d.id)}${d.init ? ` = ${renderExpr(d.init)}` : \"\"}`;\n\nconst renderPattern = (p: Pattern): string => {\n  if (p.type === \"Identifier\") {\n    assertSafeIdent(p.name);\n    return p.name;\n  }\n  if (p.type === \"RestElement\") return `...${renderPattern(p.argument)}`;\n  if (p.type === \"ArrayPattern\") return `[${p.elements.map(renderPattern).join(\", \")}]`;\n  return `{${p.properties.map((prop) => prop.type === \"RestElement\" ? `...${renderPattern(prop.argument)}` : renderPatternProperty(prop)).join(\", \")}}`;\n};\n\nconst renderPatternProperty = (p: PatternProperty): string => {\n  const key =\n    p.key.type === \"Identifier\" ? p.key.name : renderLiteral(p.key.value);\n  if (\n    p.shorthand &&\n    p.key.type === \"Identifier\" &&\n    p.value.type === \"Identifier\" &&\n    p.value.name === p.key.name\n  ) {\n    assertSafeIdent(key);\n    return key;\n  }\n  return `${key}: ${renderPattern(p.value)}`;\n};\n\nconst validateNoReservedRuntimeNames = (program: Program, reservedNames: string[]): string[] => {\n  const reserved = new Set(reservedNames);\n  const errors: string[] = [];\n\n  const hit = (name: string) => {\n    if (reserved.has(name)) errors.push(`reserved identifier: ${name}`);\n  };\n\n  const visitPattern = (p: Pattern): void => {\n    switch (p.type) {\n      case \"Identifier\":\n        hit(p.name);\n        return;\n      case \"RestElement\":\n        visitPattern(p.argument);\n        return;\n      case \"ArrayPattern\":\n        p.elements.forEach(visitPattern);\n        return;\n      case \"ObjectPattern\":\n        p.properties.forEach((prop) => {\n          if (prop.type === \"RestElement\") {\n            visitPattern(prop.argument);\n            return;\n          }\n          visitPattern(prop.value);\n        });\n        return;\n    }\n  };\n\n  const visitExpr = (e: Expr): void => {\n    switch (e.type) {\n      case \"Identifier\":\n        hit(e.name);\n        return;\n      case \"Literal\":\n        return;\n      case \"SpreadElement\":\n        visitExpr(e.argument);\n        return;\n      case \"ArrayExpression\":\n        e.elements.forEach((el) => visitExpr(el));\n        return;\n      case \"ObjectExpression\":\n        e.properties.forEach((p) => {\n          if (p.type === \"SpreadElement\") {\n            visitExpr(p.argument);\n            return;\n          }\n          if (p.shorthand && p.value.type === \"Identifier\") hit(p.value.name);\n          visitExpr(p.value);\n        });\n        return;\n      case \"AwaitExpression\":\n        visitExpr(e.argument);\n        return;\n      case \"CallExpression\":\n        visitExpr(e.callee);\n        e.arguments.forEach((a) => visitExpr(a));\n        return;\n      case \"MemberExpression\":\n        visitExpr(e.object);\n        if (e.computed) visitExpr(e.property);\n        return;\n      case \"AssignmentExpression\":\n        visitExpr(e.left);\n        visitExpr(e.right);\n        return;\n      case \"UpdateExpression\":\n        visitExpr(e.argument);\n        return;\n      case \"BinaryExpression\":\n      case \"LogicalExpression\":\n        visitExpr(e.left);\n        visitExpr(e.right);\n        return;\n      case \"UnaryExpression\":\n        visitExpr(e.argument);\n        return;\n      case \"ConditionalExpression\":\n        visitExpr(e.test);\n        visitExpr(e.consequent);\n        visitExpr(e.alternate);\n        return;\n      case \"ArrowFunctionExpression\":\n        e.params.forEach(visitPattern);\n        if (e.body.type === \"BlockStatement\") visitStmt(e.body);\n        else visitExpr(e.body);\n        return;\n    }\n  };\n\n  const visitVarDecl = (d: VarDecl) => {\n    visitPattern(d.id);\n    if (d.init) visitExpr(d.init);\n  };\n\n  const visitStmt = (s: Stmt): void => {\n    switch (s.type) {\n      case \"BlockStatement\":\n        s.body.forEach(visitStmt);\n        return;\n      case \"ExpressionStatement\":\n        visitExpr(s.expression);\n        return;\n      case \"IfStatement\":\n        visitExpr(s.test);\n        visitStmt(s.consequent);\n        if (s.alternate) visitStmt(s.alternate);\n        return;\n      case \"ReturnStatement\":\n        if (s.argument) visitExpr(s.argument);\n        return;\n      case \"VariableDeclaration\":\n        s.declarations.forEach(visitVarDecl);\n        return;\n      case \"WhileStatement\":\n        visitExpr(s.test);\n        visitStmt(s.body);\n        return;\n      case \"ForStatement\":\n        if (Array.isArray(s.init)) s.init.forEach(visitVarDecl);\n        else if (s.init) visitExpr(s.init);\n        if (s.test) visitExpr(s.test);\n        if (s.update) visitExpr(s.update);\n        visitStmt(s.body);\n        return;\n      case \"ForInStatement\":\n      case \"ForOfStatement\":\n        if (Array.isArray(s.left)) s.left.forEach(visitVarDecl);\n        else visitExpr(s.left);\n        visitExpr(s.right);\n        visitStmt(s.body);\n        return;\n      case \"BreakStatement\":\n      case \"ContinueStatement\":\n        return;\n    }\n  };\n\n  program.body.forEach(visitStmt);\n  return errors;\n};\n\n// ---------------------------------------------------------------------------\n// Runner codegen (wraps program body with fuel metering)\n// ---------------------------------------------------------------------------\n\nexport const renderWithFuel = (program: Program, fuel = 10000) => {\n  const prelude = `let __fuel = ${fuel}; const __burn = () => { if (--__fuel < 0) throw new Error(\"fuel exhausted\"); };`;\n  const body = program.body.map((s) => renderStmt(s, true)).join(\"\");\n  return `${prelude}${body}`;\n};\n\nexport const renderRunnerWithFuel = (program: Program, fuel = 10000) => {\n  const prelude = `let __fuel = ${fuel}; const __burn = () => { if (--__fuel < 0) throw new Error(\"fuel exhausted\"); };`;\n  const body = program.body.map((s) => renderStmt(s, true)).join(\"\");\n  return `${prelude}const __run = () => {${body}}; try { const ok = __run(); return { ok, fuel: __fuel }; } catch (err) { return { err: String(err), fuel: __fuel }; }`;\n};\n\nexport const renderRunnerWithFuelShared = (program: Program, fuelRefName = \"__fuel\") => {\n  assertSafeIdent(fuelRefName);\n  const reservedErrs = validateNoReservedRuntimeNames(program, [fuelRefName, \"__burn\"]);\n  if (reservedErrs.length) throw new Error(reservedErrs.join(\", \"));\n  const prelude = `const __burn = () => { if (--${fuelRefName}.value < 0) throw new Error(\"fuel exhausted\"); };`;\n  const body = program.body.map((s) => renderStmt(s, true)).join(\"\");\n  return `${prelude}const __run = () => {${body}}; try { const ok = __run(); return { ok, fuel: ${fuelRefName}.value }; } catch (err) { return { err: String(err), fuel: ${fuelRefName}.value }; }`;\n};\n\nexport const renderRunnerWithFuelSharedAsync = (program: Program, fuelRefName = \"__fuel\") => {\n  assertSafeIdent(fuelRefName);\n  const reservedErrs = validateNoReservedRuntimeNames(program, [fuelRefName, \"__burn\"]);\n  if (reservedErrs.length) throw new Error(reservedErrs.join(\", \"));\n  const prelude = `const __burn = () => { if (--${fuelRefName}.value < 0) throw new Error(\"fuel exhausted\"); };`;\n  const body = program.body.map((s) => renderStmt(s, true)).join(\"\");\n  return `${prelude}const __run = async () => {${body}}; return __run().then(ok => ({ ok, fuel: ${fuelRefName}.value })).catch(err => ({ err: String(err), fuel: ${fuelRefName}.value }));`;\n};\n\nexport const renderRunnerWithFuelAsync = (program: Program, fuel = 10000) => {\n  const prelude = `let __fuel = ${fuel}; const __burn = () => { if (--__fuel < 0) throw new Error(\"fuel exhausted\"); };`;\n  const body = program.body.map((s) => renderStmt(s, true)).join(\"\");\n  return `${prelude}const __run = async () => {${body}}; return __run().then(ok => ({ ok, fuel: __fuel })).catch(err => ({ err: String(err), fuel: __fuel }));`;\n};\n\n// ---------------------------------------------------------------------------\n// Runtime helpers\n// ---------------------------------------------------------------------------\n\nexport type runRes = { ok: unknown; fuel: number } | { err: string; fuel: number };\n\nconst SAFE_OBJECT = (() => {\n  const safe = Object.create(null) as {\n    keys: (obj: unknown) => string[];\n    values: (obj: unknown) => unknown[];\n    entries: (obj: unknown) => [string, unknown][];\n  };\n  safe.keys = (obj: unknown) => Object.keys(obj as Record<string, unknown>);\n  safe.values = (obj: unknown) => Object.values(obj as Record<string, unknown>);\n  safe.entries = (obj: unknown) => Object.entries(obj as Record<string, unknown>);\n  return Object.freeze(safe);\n})();\n\ntype FuelRef = { value: number };\ntype FunctionParam = { name: string, rest: boolean };\n\nconst parseFunctionCtor = (ctorArgs: unknown[]): { params: FunctionParam[], body: string } => {\n  if (ctorArgs.some((v) => typeof v !== \"string\")) {\n    throw new Error(\"Function arguments must be strings\");\n  }\n  const parts = ctorArgs as string[];\n  const body = parts.length ? parts[parts.length - 1] : \"\";\n  const rawParams = parts.slice(0, -1);\n  const params: FunctionParam[] = [];\n  for (const raw of rawParams) {\n    for (const seg of raw.split(\",\")) {\n      const name = seg.trim();\n      if (!name) continue;\n      const rest = name.startsWith(\"...\");\n      const base = rest ? name.slice(3) : name;\n      if (!/^[A-Za-z_$][A-Za-z0-9_$]*$/.test(base)) {\n        throw new Error(`Invalid function parameter: ${name}`);\n      }\n      params.push({ name: base, rest });\n    }\n  }\n  const restCount = params.filter((p) => p.rest).length;\n  if (restCount > 1 || (restCount === 1 && !params[params.length - 1].rest)) {\n    throw new Error(\"Rest parameter must be the last parameter\");\n  }\n  return { params, body };\n};\n\nconst mapFunctionArgs = (params: FunctionParam[], callArgs: unknown[]): Record<string, unknown> => {\n  const env: Record<string, unknown> = {};\n  let idx = 0;\n  for (const p of params) {\n    if (p.rest) {\n      env[p.name] = callArgs.slice(idx);\n      idx = callArgs.length;\n    } else {\n      env[p.name] = callArgs[idx++];\n    }\n  }\n  return env;\n};\n\nconst makeSafeFunctionSync = (fuelRef: FuelRef, outerGlobals: Record<string, unknown>) => (...ctorArgs: unknown[]) => {\n  const { params, body } = parseFunctionCtor(ctorArgs);\n  return (...callArgs: unknown[]) => {\n    const localEnv = { ...outerGlobals, ...mapFunctionArgs(params, callArgs) };\n    const res = runWithFuelShared(body, fuelRef, localEnv);\n    if (\"err\" in res) throw new Error(res.err);\n    return res.ok;\n  };\n};\n\nconst makeSafeFunctionAsync = (fuelRef: FuelRef, outerGlobals: Record<string, unknown>) => (...ctorArgs: unknown[]) => {\n  const { params, body } = parseFunctionCtor(ctorArgs);\n  return async (...callArgs: unknown[]) => {\n    const localEnv = { ...outerGlobals, ...mapFunctionArgs(params, callArgs) };\n    const res = await runWithFuelSharedAsync(body, fuelRef, localEnv);\n    if (\"err\" in res) throw new Error(res.err);\n    return res.ok;\n  };\n};\n\nconst withBuiltins = (\n  env: Record<string, unknown>,\n  fuelRef: FuelRef,\n  mode: \"sync\" | \"async\",\n): Record<string, unknown> => {\n  const baseGlobals: Record<string, unknown> = {\n    ...env,\n    Object: SAFE_OBJECT,\n    Promise,\n  };\n  return {\n    ...baseGlobals,\n    Function: mode === \"async\"\n      ? makeSafeFunctionAsync(fuelRef, baseGlobals)\n      : makeSafeFunctionSync(fuelRef, baseGlobals),\n  };\n};\n\nconst stringifyError = (err: unknown): string => {\n  if (err instanceof Error) {\n    const stack = err.stack || '';\n    const prefix = `${err.name}: ${err.message}`;\n    const cleanStack = stack\n      .replace(/^[^\\n]*\\n?/, '')\n      .replace(/spacetimedb_module:(\\d+):(\\d+)/g, '<bundled:$1:$2>');\n    return cleanStack ? `${prefix}\\n${cleanStack}` : prefix;\n  }\n  if (typeof err === 'object' && err !== null) {\n    try {\n      return JSON.stringify(err);\n    } catch {\n      return String(err);\n    }\n  }\n  return String(err);\n};\n\n// ---------------------------------------------------------------------------\n// Public runtime API\n// ---------------------------------------------------------------------------\n\nexport const runWithFuel = (\n  src: string,\n  fuel = 10000,\n  env: Record<string, unknown> = {},\n): runRes => {\n  const fuelRef = { value: fuel };\n  return runWithFuelShared(src, fuelRef, env);\n};\n\nexport const runWithFuelShared = (\n  src: string,\n  fuelRef: FuelRef,\n  env: Record<string, unknown> = {},\n  fuelRefName = \"__fuel\"\n): runRes => {\n  try {\n    const runtimeEnv = withBuiltins(env, fuelRef, \"sync\");\n    const program = parse(src);\n    const protoErrs = validateNoPrototype(program);\n    if (protoErrs.length) return { err: \"prototype access\", fuel: fuelRef.value };\n    const scopeErrs = validateScopes(program, [...Object.keys(runtimeEnv), fuelRefName]);\n    if (scopeErrs.length) return { err: scopeErrs.join(\", \"), fuel: fuelRef.value };\n    const code = renderRunnerWithFuelShared(program, fuelRefName);\n    const fullEnv = { ...runtimeEnv, [fuelRefName]: fuelRef };\n    return (new Function(...Object.keys(fullEnv), code) as (...args:unknown[]) => runRes)(...Object.values(fullEnv));\n  } catch (err) {\n    return { err: stringifyError(err), fuel: fuelRef.value };\n  }\n};\n\nexport const runWithFuelSharedAsync = async (\n  src: string,\n  fuelRef: FuelRef,\n  env: Record<string, unknown> = {},\n  fuelRefName = \"__fuel\"\n): Promise<runRes> => {\n  try {\n    const runtimeEnv = withBuiltins(env, fuelRef, \"async\");\n    const program = parse(src);\n    const protoErrs = validateNoPrototype(program);\n    if (protoErrs.length) return { err: \"prototype access\", fuel: fuelRef.value };\n    const scopeErrs = validateScopes(program, [...Object.keys(runtimeEnv), fuelRefName]);\n    if (scopeErrs.length) return { err: scopeErrs.join(\", \"), fuel: fuelRef.value };\n    const code = renderRunnerWithFuelSharedAsync(program, fuelRefName);\n    const fullEnv = { ...runtimeEnv, [fuelRefName]: fuelRef };\n    const fn = new Function(...Object.keys(fullEnv), code) as (...args: unknown[]) => Promise<runRes>;\n    return await fn(...Object.values(fullEnv));\n  } catch (err) {\n    return { err: stringifyError(err), fuel: fuelRef.value };\n  }\n};\n\nexport const runWithFuelAsync = async (\n  src: string,\n  fuel = 10000,\n  env: Record<string, unknown> = {}\n): Promise<runRes> => {\n  const fuelRef = { value: fuel };\n  return runWithFuelSharedAsync(src, fuelRef, env);\n};\n","import { runWithFuelSharedAsync } from \"@hashnotes/core/codegen\";\nimport { fromjson, hashData, type Jsonable, type Ref } from \"@hashnotes/core/notes\";\nimport { addNote, asRef, callNote, deRef, getNote } from \"./db.ts\";\nimport { HTML, type UPPER, type VDom } from \"./views.ts\";\n\ntype ClientFuelOptions = {\n  fuel?: number;\n  env?: Record<string, unknown>;\n};\n\nconst localStoreKey = (fnRef: Ref, key: Ref | Jsonable): string =>\n  `${fnRef}|${hashData(key as Jsonable)}`;\n\ntype LocalExecutor = (fn: Ref | Jsonable, arg: Ref | Jsonable) => Promise<unknown>;\n\nconst createLocalExecutor = (options: ClientFuelOptions): LocalExecutor => {\n  const fuelRef = { value: options.fuel ?? 100000 };\n  // Local runtime store is scoped to a single top-level client execution.\n  // Each called function gets isolated space via fnRef prefix.\n  const localStoreBacking = new Map<string, Jsonable>();\n\n  const callLocal: LocalExecutor = async (fnInput: Ref | Jsonable, argInput: Ref | Jsonable): Promise<unknown> => {\n    const fnRef = await asRef(fnInput);\n    const argRef = await asRef(argInput);\n\n    const fnNote = await deRef(fnRef);\n    if (typeof fnNote !== \"string\") throw new Error(\"function note must resolve to a string\");\n    const argNote = await deRef(argRef);\n\n    const store = {\n      get: (key: Ref | Jsonable): Jsonable | undefined => {\n        const skey = localStoreKey(fnRef, key);\n        return localStoreBacking.get(skey);\n      },\n      set: (key: Ref | Jsonable, value: Ref | Jsonable): Jsonable => {\n        const skey = localStoreKey(fnRef, key);\n        localStoreBacking.set(skey, value as Jsonable);\n        return value as Jsonable;\n      },\n    };\n\n    const remote = async (remoteFn: Ref | Jsonable, remoteArg?: Ref | Jsonable): Promise<Jsonable> =>\n      callNote(remoteFn, remoteArg === undefined ? null : remoteArg);\n\n    const result = await runWithFuelSharedAsync(\n      fnNote,\n      fuelRef,\n      {\n        ...(options.env ?? {}),\n        arg: argNote,\n        argRef,\n        call: callLocal,\n        callNote: callLocal,\n        remote,\n        store,\n        addNote,\n        getNote,\n        asRef,\n        deref: deRef,\n        hashData,\n        fromjson,\n        HTML,\n      }\n    );\n\n    if (\"err\" in result) throw new Error(result.err);\n    return result.ok;\n  };\n\n  return callLocal;\n};\n\nexport const callNoteClient = async (\n  fn: Ref | Jsonable,\n  arg?: Ref | Jsonable,\n  options: ClientFuelOptions = {}\n): Promise<Jsonable> => {\n  const callLocal = createLocalExecutor(options);\n  return (await callLocal(fn, arg === undefined ? null : arg)) as Jsonable;\n};\n\nexport const callViewClient = async (\n  fn: Ref | Jsonable,\n  arg?: Ref | Jsonable,\n  options: ClientFuelOptions = {}\n): Promise<(upper: UPPER) => VDom> => {\n  const callLocal = createLocalExecutor(options);\n  const result = await callLocal(fn, arg === undefined ? null : arg);\n  if (typeof result !== \"function\") {\n    throw new Error(\"view function must return (upper) => VDom\");\n  }\n  return result as (upper: UPPER) => VDom;\n};\n","import { callViewClient, renderDom } from \"@hashnotes/lib\";\nimport { isRef, type Ref } from \"@hashnotes/core/notes\";\nimport { getServer } from \"../../lib/src/db\";\n\nconst parseRefFromPath = (pathname: string): Ref | null => {\n  const segment = pathname.replace(/^\\/+/, \"\").split(\"/\")[0];\n  if (!segment) return null;\n\n  const decoded = decodeURIComponent(segment).trim();\n  if (!decoded) return null;\n\n  if (isRef(decoded)) return decoded;\n  if (/^[a-f0-9]{32}$/i.test(decoded)) return `#${decoded}`;\n  return null;\n};\n\nexport const boot = async () => {\n  const mount = document.getElementById(\"app\") ?? document.body;\n  const ref = parseRefFromPath(window.location.pathname);\n  if (!ref) {\n    mount.innerHTML = \"\";\n    mount.textContent = \"Open /<note-hash> to render that note as a view.\";\n    return;\n  }\n\n  try {\n    const view = await callViewClient(ref, {});\n    const el = renderDom(view);\n    mount.innerHTML = \"\";\n    mount.append(el);\n  } catch (err) {\n    mount.innerHTML = `<pre>Failed to render note ${ref} on server ${getServer()}: ${String(err)}</pre>`;\n  }\n};\n","import { boot } from \"./main.ts\";\n\nboot().catch((err) => {\n  console.error(err);\n  const mount = document.getElementById(\"app\") ?? document.body;\n  mount.textContent = `App boot failed: ${String(err)}`;\n});\n"],"names":["text","start","body","elements"],"mappings":"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"}